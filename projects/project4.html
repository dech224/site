<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LED Memory Game</title>
  <link rel="stylesheet" href="../style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;700&display=swap" rel="stylesheet" />
</head>
<body>

<div class = "cursor_light"> </div>

<nav class="main-nav">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="javascript:history.back()">Previous</a></li>
  </ul>
</nav>


  <section class="fade-in" style="max-width: 1150px; margin: auto; padding: 80px 20px;">
    <h2>LED Memory Game</h2>
    <p>Call and response game that generates a random sequence of LED flashes that the user has to remember. 
      Four different "game modes" with LCD screen display. Circuit powered by ESP32 Microcontroller.</p>

    <div class="image-row">

     <img src="../images/project1_img2.jpeg" alt="Project 1 Img2" class="half-img">
  <img src="../images/project1_img1.jpeg" alt="Project 1 Img1" class="half-img">
 
</div>

    <video autoplay loop muted playsinline style="max-width: 100%; border-radius: 8px; margin-top: 40px;">
  <source src="../videos/project1_video.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<h2>How It Works</h2>
<p>The ESP32 generates a random sequence of LED flashes that the player must memorize and repeat back by pressing the matching buttons. 
Each round, the sequence grows longer, increasing the difficulty. An LCD screen displays the current game mode and feedback. 
There are four different modes, including normal mode, hard mode (faster), increase mode (gradual spike in difficulty), and "Impossible Mode" 
(much faster).
The game continues until the player makes an error.</p>

<h2>Skills Used</h2>
<p><ul> <li>Random sequence generation and memory logic in C++</li>
  <li>LED and button interfacing with debouncing</li>
  <li>LCD (I2C) display integration for modes and feedback</li>
  <li>Game state management with multiple difficulty modes</li>
  <li>Microcontroller programming (ESP32)</li></ul></p>

<h2>Hardware</h2>
<p><ul><li>ESP32 Dev Board</li>
<li>4x Resistors (2x 220 ohms, 1x 330 ohms, 1x 1.1k ohms for LEDS, 1x 220 ohms for Passive Buzzer)</li>
<li>4x LEDs (Red, Yellow, Green, and Blue)</li>
<li>1x Passive Buzzer</li>
<li>4x Pushbuttons</li>
<li>Breadboard & Jumper Wires</li></ul></p>

<h2>Circuit Diagram</h2>

<img src="../images/project1_diagram.jpg" alt="Project 1 Circuit" style="width: 100%; margin-top: 40px; border-radius: 8px;">

<h2>Voltage Divider</h2>
<p>I used the Voltage Divider Equation</p>
<p>
  \[
    V_{out} = V_{in} \times \frac{R_2}{R_1 + R_2}
  \]
</p>

<p>To solve for the resistor ratio when dropping from 5V to 3.3V:</p>

  <p>\[
  \frac{V_{\text{out}}}{V_{\text{in}}} = \frac{R_2}{R_1 + R_2}
  \]</p>

  <p>\[
  \frac{V_{\text{in}}}{V_{\text{out}}} = \frac{R_1 + R_2}{R_2}
  \]</p>

  <p>\[
  \frac{V_{\text{in}}}{V_{\text{out}}} = \frac{R_1}{R_2} + 1
  \]</p>

  <p>\[
  \frac{R_1}{R_2} = \frac{V_{\text{in}}}{V_{\text{out}}} - 1
  \]</p>

  <p>Now plug in values:</p>

  <p>\[
  \frac{R_1}{R_2} = \frac{5}{3.3} - 1 = 1.515 - 1 = 0.515
  \]</p>

  <p>This means \( R_1 = 0.515 \cdot R_2 \). Choose any resistor for \( R_2 \), then calculate \( R_1 \) based on this ratio.</p>

  <p>I opted for \( R_2 = 2 \). Making \( R_1 = 0.515 \cdot 2 \approx 1 \)  </p>

  <h2>Distance Equation</h2>
  <p>In my code I took the time it took for the ultrasonic sensor to "sense" an object and bounce back, recorded by the echo pin, in
    order to find the distance from the sensor to the object.
  </p>
  <p>\[
\texttt{long duration = pulseIn(echo_Pin, HIGH);}
\]</p>
<p>The speed of sound is approximately:</p>

<p>
  \[
  343\ \text{m/s} = 34300\ \text{cm/s}
  \]
</p>

<p>The sensor returns duration in microseconds, so I convert to cm/Î¼s:</p>

<p>
  \[
  \frac{34300\ \text{cm/s}}{1{,}000{,}000\ \mu s/s} = 0.0343\ \text{cm}/\mu s
  \]
</p>



  <p>Then, using the distance equation:</p>
<p>\[
\Delta x = \Delta t \cdot v
\]</p>
<p>And dividing by two to account for the time it takes to go to the object and bounce back:</p>
<p>Therefore:</p>

<p>
  \[
  \text{Distance} = \frac{\text{duration} \times 0.034}{2}
  \]
</p>
  <p>\[
\texttt{float dist = duration * 0.034 / 2;}
\]</p>

<h2>Gate Logic</h2>
<p>If an object is less than 15 cm away from the sensor the green LED turns on, the red LED turns off, and the gate is opened. 
    When an object is more than 15 cm away from the sensor the green LED turns off, the red LED turns on, and the gate is closed.</p>
<p>\[
\begin{aligned}
&\texttt{if (dist < 15) \{} \\
&\quad \texttt{digitalWrite(LED_Green, HIGH);} \\
&\quad \texttt{digitalWrite(LED_Red, LOW);} \\
&\quad \texttt{myServo.write(0);} \\
&\texttt{\} else \{} \\
&\quad \texttt{digitalWrite(LED_Green, LOW);} \\
&\quad \texttt{digitalWrite(LED_Red, HIGH);} \\
&\quad \texttt{myServo.write(90);} \\
&\texttt{\}}
\end{aligned}
\]</p>


<a href="https://github.com/dech224/ESP32-Motion-Activated-Gate" target="_blank" class="github-button">
  <img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" class="github-icon">
  View on GitHub
</a>

  </section>


  
<script>
  const faders = document.querySelectorAll('.fade-in');
  const appearOptions = {
    threshold: 0.1,
    rootMargin: "0px 0px -50px 0px"
  };
  const appearOnScroll = new IntersectionObserver(function(entries, observer) {
    entries.forEach(entry => {
      if (!entry.isIntersecting) return;
      entry.target.classList.add('appear');
      observer.unobserve(entry.target);
    });
  }, appearOptions);

  faders.forEach(fader => {
    appearOnScroll.observe(fader);
  });
</script>

<script>
  const cursorLight = document.querySelector('.cursor_light');

  document.addEventListener('mousemove', (e) => {
    cursorLight.style.top = `${e.clientY}px`;
    cursorLight.style.left = `${e.clientX}px`;
  });
</script>




<script>
  function applyAccent(mode) {
    const r = document.documentElement.style;

    if (mode === "cool" || mode === "cool-mode") {
      r.setProperty('--accent-color', '#74c0ff');
      r.setProperty('--text-color', '#002244');
      r.setProperty('--btn-hover', '#5aadee');
    } else if (mode === "warm" || mode === "warm-mode") {
      r.setProperty('--accent-color', '#f4a261');
      r.setProperty('--text-color', '#442200');
      r.setProperty('--btn-hover', '#dd8a42');
    } else if (mode === "dark" || mode === "dark-mode") {
      r.setProperty('--accent-color', '#76a9fa');
      r.setProperty('--text-color', '#e5e5e5');
      r.setProperty('--btn-hover', '#3c3f41');
    } else {
      r.setProperty('--accent-color', '#1f5ab0');
      r.setProperty('--text-color', '#111');
      r.setProperty('--btn-hover', '#2563eb');
    }
  }

  const savedTheme = localStorage.getItem('activeTheme') || 'default';
  document.body.classList.add(savedTheme + '-mode');
  applyAccent(savedTheme);
</script>


</body>
</html>

